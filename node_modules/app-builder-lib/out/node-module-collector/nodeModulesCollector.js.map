{"version":3,"file":"nodeModulesCollector.js","sourceRoot":"","sources":["../../src/node-module-collector/nodeModulesCollector.ts"],"names":[],"mappings":"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","sourcesContent":["import { exists, log, retry, TmpDir } from \"builder-util\"\nimport * as childProcess from \"child_process\"\nimport * as fs from \"fs-extra\"\nimport { createWriteStream } from \"fs-extra\"\nimport { Lazy } from \"lazy-val\"\nimport * as path from \"path\"\nimport { hoist, type HoisterResult, type HoisterTree } from \"./hoist\"\nimport { ModuleManager } from \"./moduleManager\"\nimport { getPackageManagerCommand, PM } from \"./packageManager\"\nimport type { Dependency, DependencyGraph, NodeModuleInfo, PackageJson } from \"./types\"\n\nexport abstract class NodeModulesCollector<ProdDepType extends Dependency<ProdDepType, OptionalDepType>, OptionalDepType> {\n  private readonly nodeModules: NodeModuleInfo[] = []\n  protected readonly allDependencies: Map<string, ProdDepType> = new Map()\n  protected readonly productionGraph: DependencyGraph = {}\n  protected readonly cache: ModuleManager = new ModuleManager()\n\n  protected isHoisted = new Lazy<boolean>(async () => {\n    const { manager } = this.installOptions\n    const command = getPackageManagerCommand(manager)\n    const config = (await this.asyncExec(command, [\"config\", \"list\"])).stdout\n    if (config == null) {\n      log.debug({ manager }, \"unable to determine if node_modules are hoisted: no config output. falling back to hoisted mode\")\n      return false\n    }\n    const lines = Object.fromEntries(config.split(\"\\n\").map(line => line.split(\"=\").map(s => s.trim())))\n    if (lines[\"node-linker\"] === \"hoisted\") {\n      log.debug({ manager }, \"node_modules are hoisted\")\n      return true\n    }\n    return false\n  })\n\n  constructor(\n    protected readonly rootDir: string,\n    private readonly tempDirManager: TmpDir\n  ) {}\n\n  /**\n   * Retrieves and collects all Node.js modules for a given package.\n   *\n   * This method orchestrates the entire module collection process by:\n   * 1. Fetching the dependency tree from the package manager\n   * 2. Collecting all dependencies recursively\n   * 3. Extracting workspace references if applicable\n   * 4. Building a production dependency graph\n   * 5. Hoisting the dependencies to their final locations\n   * 6. Resolving and returning module information\n   *\n   * @param options - Configuration object\n   * @param options.packageName - The name of the package to collect modules for\n   * @returns Promise resolving to an array of NodeModuleInfo objects representing all collected modules\n   */\n  public async getNodeModules({ packageName }: { packageName: string }): Promise<NodeModuleInfo[]> {\n    const tree: ProdDepType = await this.getDependenciesTree(this.installOptions.manager)\n\n    await this.collectAllDependencies(tree, packageName)\n    const realTree: ProdDepType = this.getTreeFromWorkspaces(tree, packageName)\n    await this.extractProductionDependencyGraph(realTree, packageName)\n\n    const hoisterResult: HoisterResult = hoist(this.transformToHoisterTree(this.productionGraph, packageName), {\n      check: log.isDebugEnabled,\n    })\n\n    await this._getNodeModules(hoisterResult.dependencies, this.nodeModules)\n    log.debug({ packageName, depCount: this.nodeModules.length }, \"node modules collection complete\")\n\n    return this.nodeModules\n  }\n\n  public abstract readonly installOptions: {\n    manager: PM\n    lockfile: string\n  }\n\n  protected abstract getArgs(): string[]\n  protected abstract extractProductionDependencyGraph(tree: Dependency<ProdDepType, OptionalDepType>, dependencyId: string): Promise<void>\n  protected abstract collectAllDependencies(tree: Dependency<ProdDepType, OptionalDepType>, appPackageName: string): Promise<void>\n\n  /**\n   * Retrieves the dependency tree from the package manager.\n   *\n   * Executes the appropriate package manager command to fetch the dependency tree and writes\n   * the output to a temporary file. Includes retry logic to handle transient failures such as\n   * incomplete JSON output or missing files. Will retry up to 1 time with exponential backoff.\n   *\n   * @param pm - The package manager to use (npm, yarn, pnpm, etc.)\n   * @returns Promise resolving to the parsed dependency tree\n   * @throws {Error} If the dependency tree cannot be retrieved after retries\n   */\n  protected async getDependenciesTree(pm: PM): Promise<ProdDepType> {\n    const command = getPackageManagerCommand(pm)\n    const args = this.getArgs()\n\n    const tempOutputFile = await this.tempDirManager.getTempFile({\n      prefix: path.basename(command, path.extname(command)),\n      suffix: \"output.json\",\n    })\n\n    return retry(\n      async () => {\n        await this.streamCollectorCommandToFile(command, args, this.rootDir, tempOutputFile)\n        const shellOutput = await fs.readFile(tempOutputFile, { encoding: \"utf8\" })\n        const result = await Promise.resolve(this.parseDependenciesTree(shellOutput))\n        return result\n      },\n      {\n        retries: 1,\n        interval: 2000,\n        backoff: 2000,\n        shouldRetry: async (error: any) => {\n          const fields: Record<string, string> = { error: error.message, tempOutputFile, cwd: this.rootDir, packageManager: pm }\n\n          if (!(await exists(tempOutputFile))) {\n            log.debug(fields, \"dependency tree output file missing, retrying\")\n            return true\n          }\n\n          const fileContent = await fs.readFile(tempOutputFile, { encoding: \"utf8\" })\n          fields.fileContentLength = fileContent.length.toString()\n\n          if (fileContent.trim().length === 0) {\n            log.debug(fields, \"dependency tree output file empty, retrying\")\n            return true\n          }\n\n          // extract small start/end sample for debugging purposes (e.g. polluted console output)\n          const lines = fileContent.split(\"\\n\")\n          const lineSampleSize = Math.min(5, lines.length / 2)\n          if (2 * lineSampleSize > 5) {\n            fields.sampleStart = lines.slice(0, lineSampleSize).join(\"\\n\")\n            fields.sampleEnd = lines.slice(-lineSampleSize).join(\"\\n\")\n          } else {\n            fields.content = fileContent\n          }\n\n          if (error.message?.includes(\"Unexpected end of JSON input\")) {\n            log.debug(fields, \"JSON parse error in dependency tree, retrying\")\n            return true\n          }\n\n          log.error(fields, \"error parsing dependencies tree\")\n          return false\n        },\n      }\n    )\n  }\n\n  /**\n   * Parses the dependencies tree from shell command output.\n   *\n   **/\n  protected parseDependenciesTree(shellOutput: string): ProdDepType | Promise<ProdDepType> {\n    return this.extractJsonFromPollutedOutput<ProdDepType>(shellOutput)\n  }\n\n  protected extractJsonFromPollutedOutput<T>(shellOutput: string): T {\n    const consoleOutput = shellOutput.trim()\n    try {\n      // Please for the love of all that is holy, this should cover 99% of cases where npm/pnpm/yarn output is clean JSON\n      return JSON.parse(consoleOutput)\n    } catch {\n      // ignore\n    }\n\n    // DEDICATED FALLBACK FOR POLLUTED OUTPUT, non-trivial to implement correctly, not needed in most cases, and highly inefficient\n\n    // Find the first index that starts with { or [\n    const bracketOpen = Math.max(consoleOutput.indexOf(\"{\"), 0)\n    const bracketOpenSquare = Math.max(consoleOutput.indexOf(\"[\"), 0)\n    const start = Math.min(bracketOpen, bracketOpenSquare) // always non-negative due to Math.max above\n\n    for (let i = start; i < consoleOutput.length; i++) {\n      const slice = consoleOutput.slice(start, i + 1)\n      try {\n        return JSON.parse(slice)\n      } catch {\n        // ignore, try next\n      }\n    }\n    throw new Error(\"No JSON content found in output\")\n  }\n\n  protected cacheKey(pkg: Pick<ProdDepType, \"name\" | \"version\" | \"path\">): string {\n    const rel = path.relative(this.rootDir, pkg.path)\n    return `${pkg.name}::${pkg.version}::${rel ?? \".\"}`\n  }\n\n  protected packageVersionString(pkg: Pick<ProdDepType, \"name\" | \"version\">): string {\n    return `${pkg.name}@${pkg.version}`\n  }\n\n  /**\n   * Determines if a given dependency is a production dependency of a package.\n   *\n   * Checks both the dependencies and optionalDependencies of a package to see if\n   * the specified dependency name is listed.\n   *\n   * @param depName - The name of the dependency to check\n   * @param pkg - The package to search for the dependency in\n   * @returns True if the dependency is found in either dependencies or optionalDependencies, false otherwise\n   */\n  protected isProdDependency(depName: string, pkg: ProdDepType): boolean {\n    const prodDeps = { ...pkg.dependencies, ...pkg.optionalDependencies }\n    return prodDeps[depName] != null\n  }\n\n  protected async locatePackageWithVersion(depTree: Pick<ProdDepType, \"name\" | \"version\" | \"path\">): Promise<{ packageDir: string; packageJson: PackageJson } | null> {\n    const result = await this.cache.locatePackageVersion({\n      parentDir: depTree.path,\n      pkgName: depTree.name,\n      requiredRange: depTree.version,\n    })\n    return result\n  }\n  /**\n   * Parses a dependency identifier string into name and version components.\n   *\n   * Handles both scoped packages (e.g., \"@scope/pkg@1.2.3\") and regular packages (e.g., \"pkg@1.2.3\").\n   * If the identifier is malformed or cannot be parsed, defaults to treating the entire string as\n   * the package name with an \"unknown\" version.\n   */\n  protected parseNameVersion(identifier: string): { name: string; version: string } {\n    const lastAt = identifier.lastIndexOf(\"@\")\n    if (lastAt <= 0) {\n      // fallback for scoped packages or malformed strings\n      return { name: identifier, version: \"unknown\" }\n    }\n    const name = identifier.slice(0, lastAt)\n    const version = identifier.slice(lastAt + 1)\n    return { name, version }\n  }\n\n  /**\n   * Retrieves the dependency tree and handles workspace package self-references.\n   *\n   * If the project is a workspace project, this method removes the root package's self-reference\n   * from the dependency tree to avoid circular dependencies. It promotes the root package's\n   * direct dependencies to the top level of the tree.\n   *\n   * @param tree - The original dependency tree\n   * @param packageName - The name of the package to check for and remove from the tree\n   * @returns The extracted dependency subtree\n   */\n  protected getTreeFromWorkspaces(tree: ProdDepType, packageName: string): ProdDepType {\n    if (tree.workspaces && tree.dependencies) {\n      for (const [key, value] of Object.entries(tree.dependencies)) {\n        if (key === packageName) {\n          return value\n        }\n      }\n    }\n\n    return tree\n  }\n\n  private transformToHoisterTree(obj: DependencyGraph, key: string, nodes: Map<string, HoisterTree> = new Map()): HoisterTree {\n    let node = nodes.get(key)\n    const { name, version } = this.parseNameVersion(key)\n\n    if (!node) {\n      node = {\n        name,\n        identName: name,\n        reference: version,\n        dependencies: new Set<HoisterTree>(),\n        peerNames: new Set<string>(),\n      }\n\n      nodes.set(key, node)\n\n      const deps = (obj[key] || {}).dependencies || []\n      for (const dep of deps) {\n        const child = this.transformToHoisterTree(obj, dep, nodes)\n        node.dependencies.add(child)\n      }\n    }\n\n    return node\n  }\n\n  private async _getNodeModules(dependencies: Set<HoisterResult>, result: NodeModuleInfo[]) {\n    if (dependencies.size === 0) {\n      return\n    }\n\n    for (const d of dependencies.values()) {\n      const reference = [...d.references][0]\n      const p = this.allDependencies.get(`${d.name}@${reference}`)?.path\n      if (p === undefined) {\n        log.warn({ name: d.name, reference }, \"cannot find path for dependency\")\n        continue\n      }\n\n      // fix npm list issue\n      // https://github.com/npm/cli/issues/8535\n      if (!(await this.cache.exists[p])) {\n        log.debug({ name: d.name, reference, p }, \"dependency path does not exist\")\n        continue\n      }\n\n      const node: NodeModuleInfo = {\n        name: d.name,\n        version: reference,\n        dir: await this.cache.realPath[p],\n      }\n      result.push(node)\n      if (d.dependencies.size > 0) {\n        node.dependencies = []\n        await this._getNodeModules(d.dependencies, node.dependencies)\n      }\n    }\n    result.sort((a, b) => a.name.localeCompare(b.name))\n  }\n\n  async asyncExec(command: string, args: string[], cwd: string = this.rootDir): Promise<{ stdout: string | undefined; stderr: string | undefined }> {\n    const file = await this.tempDirManager.getTempFile({ prefix: \"exec-\", suffix: \".txt\" })\n    try {\n      await this.streamCollectorCommandToFile(command, args, cwd, file)\n      const result = await fs.readFile(file, { encoding: \"utf8\" })\n      return { stdout: result?.trim(), stderr: undefined }\n    } catch (error: any) {\n      log.debug({ error: error.message }, \"failed to execute command\")\n      return { stdout: undefined, stderr: error.message }\n    }\n  }\n\n  /**\n   * Executes a command and streams its output to a file.\n   *\n   * Spawns a child process to execute the specified command with arguments, capturing stdout\n   * to a file. Handles Windows-specific quirks by wrapping .cmd files in a temporary .bat file\n   * when necessary. Enables corepack strict mode by default but allows process.env overrides.\n   *\n   * Special handling for `npm list` exit code 1, which is expected in certain scenarios.\n   *\n   * @param command - The command to execute\n   * @param args - Array of command-line arguments\n   * @param cwd - The working directory to execute the command in\n   * @param tempOutputFile - The path to the temporary file where stdout will be written\n   * @returns Promise that resolves when the command completes successfully or rejects if it fails\n   * @throws {Error} If the child process spawn fails or exits with a non-zero code\n   */\n  async streamCollectorCommandToFile(command: string, args: string[], cwd: string, tempOutputFile: string) {\n    const execName = path.basename(command, path.extname(command))\n    const isWindowsScriptFile = process.platform === \"win32\" && path.extname(command).toLowerCase() === \".cmd\"\n    if (isWindowsScriptFile) {\n      // If the command is a Windows script file (.cmd), we need to wrap it in a .bat file to ensure it runs correctly with cmd.exe\n      // This is necessary because .cmd files are not directly executable in the same way as .bat files.\n      // We create a temporary .bat file that calls the .cmd file with the provided arguments. The .bat file will be executed by cmd.exe.\n      // Note: This is a workaround for Windows command execution quirks for specifically when `shell: false`\n      const tempBatFile = await this.tempDirManager.getTempFile({\n        prefix: execName,\n        suffix: \".bat\",\n      })\n      const batScript = `@echo off\\r\\n\"${command}\" %*\\r\\n` // <-- CRLF required for .bat\n      await fs.writeFile(tempBatFile, batScript, { encoding: \"utf8\" })\n      command = \"cmd.exe\"\n      args = [\"/c\", tempBatFile, ...args]\n    }\n\n    await new Promise<void>((resolve, reject) => {\n      const outStream = createWriteStream(tempOutputFile)\n\n      const child = childProcess.spawn(command, args, {\n        cwd,\n        env: { COREPACK_ENABLE_STRICT: \"0\", ...process.env }, // allow `process.env` overrides\n        shell: true, // `true`` is now required: https://github.com/electron-userland/electron-builder/issues/9488\n      })\n\n      let stderr = \"\"\n      child.stdout.pipe(outStream)\n      child.stderr.on(\"data\", chunk => {\n        stderr += chunk.toString()\n      })\n      child.on(\"error\", err => {\n        reject(new Error(`Node module collector spawn failed: ${err.message}`))\n      })\n\n      child.on(\"close\", code => {\n        outStream.close()\n        // https://github.com/npm/npm/issues/17624\n        const shouldIgnore = code === 1 && \"npm\" === execName.toLowerCase() && args.includes(\"list\")\n        if (shouldIgnore) {\n          log.debug(null, \"`npm list` returned non-zero exit code, but it MIGHT be expected (https://github.com/npm/npm/issues/17624). Check stderr for details.\")\n        }\n        if (stderr.length > 0) {\n          log.debug({ stderr }, \"note: there was node module collector output on stderr\")\n        }\n        const shouldResolve = code === 0 || shouldIgnore\n        return shouldResolve ? resolve() : reject(new Error(`Node module collector process exited with code ${code}:\\n${stderr}`))\n      })\n    })\n  }\n}\n"]}