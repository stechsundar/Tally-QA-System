{"version":3,"file":"asarUtil.js","sourceRoot":"","sources":["../../src/asar/asarUtil.ts"],"names":[],"mappings":"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","sourcesContent":["import { createPackageFromStreams, AsarStreamType, AsarDirectory } from \"@electron/asar\"\nimport { isEmptyOrSpaces, log } from \"builder-util\"\nimport { exists, Filter, FilterStats } from \"builder-util/out/fs\"\nimport * as fs from \"fs-extra\"\nimport { readlink } from \"fs-extra\"\nimport * as path from \"path\"\nimport { AsarOptions } from \"../options/PlatformSpecificBuildOptions\"\nimport { PlatformPackager } from \"../platformPackager\"\nimport { ResolvedFileSet, getDestinationPath } from \"../util/appFileCopier\"\nimport { detectUnpackedDirs } from \"./unpackDetector\"\nimport { Readable } from \"stream\"\nimport * as os from \"os\"\n\nconst resolvePath = async (file: string | undefined): Promise<string | undefined> => (file && (await exists(file)) ? fs.realpath(file).catch(() => path.resolve(file)) : undefined)\nconst resolvePaths = async (filepaths: (string | undefined)[]) => {\n  return Promise.all(filepaths.map(resolvePath)).then(paths => paths.filter((it): it is string => it != null))\n}\n\nconst DENYLIST = resolvePaths([\n  \"/usr\",\n  \"/lib\",\n  \"/bin\",\n  \"/sbin\",\n  \"/etc\",\n\n  \"/tmp\",\n  \"/var\", // block whole /var by default. If $HOME is under /var, it's explicitly in ALLOWLIST - https://github.com/electron-userland/electron-builder/issues/9025#issuecomment-3575380041\n\n  // macOS system directories\n  \"/System\",\n  \"/Library\",\n  \"/private\",\n\n  // Windows system directories\n  process.env.SystemRoot,\n  process.env.WINDIR,\n])\n\nconst ALLOWLIST = resolvePaths([\n  os.tmpdir(), // always allow temp dir\n  os.homedir(), // always allow home dir\n])\n\n/** @internal */\nexport class AsarPackager {\n  private readonly outFile: string\n\n  constructor(\n    readonly packager: PlatformPackager<any>,\n    private readonly config: {\n      defaultDestination: string\n      resourcePath: string\n      options: AsarOptions\n      unpackPattern: Filter | undefined\n    }\n  ) {\n    this.outFile = path.join(config.resourcePath, `app.asar`)\n  }\n\n  async pack(fileSets: Array<ResolvedFileSet>) {\n    const orderedFileSets = [\n      // Write dependencies first to minimize offset changes to asar header\n      ...fileSets.slice(1),\n\n      // Finish with the app files that change most often\n      fileSets[0],\n    ].map(set => this.orderFileSet(set))\n\n    const streams = await this.processFileSets(orderedFileSets)\n    await this.executeElectronAsar(streams)\n  }\n\n  private async executeElectronAsar(streams: AsarStreamType[]) {\n    // override logger temporarily to clean up console (electron/asar does some internal logging that blogs up the default electron-builder logs)\n    const consoleLogger = console.log\n    console.log = (...args) => {\n      if (args[0] === \"Ordering file has 100% coverage.\") {\n        return // no need to log, this means our ordering logic is working correctly\n      }\n      log.info({ args }, \"logging @electron/asar\")\n    }\n    await createPackageFromStreams(this.outFile, streams)\n    console.log = consoleLogger\n  }\n\n  private async processFileSets(fileSets: ResolvedFileSet[]): Promise<AsarStreamType[]> {\n    const unpackedPaths = new Set<string>()\n    if (this.config.options.smartUnpack !== false) {\n      for (const fileSet of fileSets) {\n        detectUnpackedDirs(fileSet, unpackedPaths)\n      }\n    }\n\n    const resultsMap = new Map<string, AsarStreamType>()\n    const streamOrdering: string[] = []\n    const normalizedUnpackedPaths = Array.from(unpackedPaths).map(p => path.normalize(p))\n\n    // Check whether a file or directory should be unpacked, using pre-normalized unpacked paths and early returns\n    const isUnpacked = (dir: string, file?: string, stat?: FilterStats): boolean => {\n      const normalizedDir = path.normalize(dir)\n\n      // Check file pattern first (most specific)\n      if (!isEmptyOrSpaces(file) && stat && this.config.unpackPattern?.(file, stat)) {\n        return true\n      }\n\n      // Check if path is within any unpacked directory\n      for (const unpackedPath of normalizedUnpackedPaths) {\n        if (normalizedDir === unpackedPath || normalizedDir.startsWith(unpackedPath + path.sep)) {\n          return true\n        }\n      }\n\n      return false\n    }\n\n    // First pass: process all files in order, ensuring parent directories exist\n    for (const fileSet of fileSets) {\n      // Don't use Promise.all, we need to retain order of execution/iteration through the already-ordered fileset\n      for (const [index, file] of fileSet.files.entries()) {\n        const transformedData = fileSet.transformedFiles?.get(index)\n        const stat = fileSet.metadata.get(file)!\n        const destination = path.relative(this.config.defaultDestination, getDestinationPath(file, fileSet))\n\n        // Ensure parent directories exist before processing file\n        this.ensureParentDirectories(destination, resultsMap, streamOrdering)\n\n        const result = await this.processFileOrSymlink({\n          file,\n          destination,\n          fileSet,\n          transformedData,\n          stat,\n          isUnpacked,\n        })\n\n        if (result && !resultsMap.has(result.path)) {\n          resultsMap.set(result.path, result)\n          streamOrdering.push(result.path)\n        }\n      }\n    }\n\n    // Second pass: propagate unpacked flag to parent directories\n    for (const entry of resultsMap.values()) {\n      if (entry.unpacked) {\n        this.markParentDirectoriesAsUnpacked(entry.path, resultsMap, isUnpacked)\n      }\n    }\n\n    // Build final results array maintaining processing order\n    return streamOrdering.reduce<AsarStreamType[]>((streams, path) => {\n      const stream = resultsMap.has(path) ? resultsMap.get(path) : null\n      if (stream != null) {\n        streams.push(stream)\n      }\n      return streams\n    }, [])\n  }\n\n  private ensureParentDirectories(destination: string, resultsMap: Map<string, AsarStreamType>, streamOrdering: string[]): void {\n    const parents: string[] = []\n    let current = path.dirname(path.normalize(destination))\n\n    // Collect all parent directories from deepest to root\n    while (current !== \".\") {\n      parents.unshift(current)\n      current = path.dirname(current)\n    }\n\n    // Add parent directories in order (root to deepest)\n    for (const parentPath of parents) {\n      if (!resultsMap.has(parentPath)) {\n        const dir: AsarDirectory = {\n          type: \"directory\",\n          path: parentPath,\n          unpacked: false, // Updated in second pass if needed\n        }\n        resultsMap.set(parentPath, dir)\n        streamOrdering.push(parentPath)\n      }\n    }\n  }\n\n  private markParentDirectoriesAsUnpacked(destination: string, resultsMap: Map<string, AsarStreamType>, isUnpacked: (path: string) => boolean): void {\n    let current = path.dirname(path.normalize(destination))\n\n    while (current !== \".\") {\n      const entry = resultsMap.get(current)\n      if (entry && isUnpacked(current)) {\n        entry.unpacked = true\n      }\n      current = path.dirname(current)\n    }\n  }\n\n  private async processFileOrSymlink(options: {\n    file: string\n    destination: string\n    stat: fs.Stats\n    fileSet: ResolvedFileSet\n    transformedData: string | Buffer | undefined\n    isUnpacked: (dir: string, file?: string, stat?: FilterStats) => boolean\n  }): Promise<AsarStreamType> {\n    const { isUnpacked, transformedData, file, destination, stat } = options\n    const unpacked = isUnpacked(destination, file, stat)\n\n    // Handle directories\n    if (!stat.isFile() && !stat.isSymbolicLink()) {\n      return { path: destination, unpacked, type: \"directory\" }\n    }\n\n    // Handle transformed data (pre-processed content)\n    if (transformedData != null) {\n      const size = Buffer.byteLength(transformedData)\n      return {\n        path: destination,\n        streamGenerator: () =>\n          new Readable({\n            read() {\n              this.push(transformedData)\n              this.push(null)\n            },\n          }),\n        unpacked,\n        type: \"file\",\n        stat: { mode: stat.mode, size },\n      }\n    }\n\n    // verify that the file is not a direct link or symlinked to access/copy a system file\n    await this.protectSystemAndUnsafePaths(file, await this.packager.info.getWorkspaceRoot())\n\n    const baseConfig = {\n      path: destination,\n      streamGenerator: () => fs.createReadStream(file),\n      unpacked,\n      stat,\n    }\n\n    // Handle regular files\n    if (!stat.isSymbolicLink()) {\n      return { ...baseConfig, type: \"file\" }\n    }\n\n    // Handle symlinks - make relative to source location\n    let link = await readlink(file)\n    if (path.isAbsolute(link)) {\n      link = path.relative(path.dirname(file), link)\n    }\n\n    return {\n      ...baseConfig,\n      type: \"link\",\n      symlink: link,\n    }\n  }\n\n  private orderFileSet(fileSet: ResolvedFileSet): ResolvedFileSet {\n    const sortedFileEntries = Array.from(fileSet.files.entries())\n\n    sortedFileEntries.sort(([, a], [, b]) => {\n      if (a === b) {\n        return 0\n      }\n\n      // Place addons last because their signature changes per build\n      const isAAddon = a.endsWith(\".node\")\n      const isBAddon = b.endsWith(\".node\")\n      if (isAAddon && !isBAddon) {\n        return 1\n      }\n      if (isBAddon && !isAAddon) {\n        return -1\n      }\n\n      // Otherwise order by name\n      return a < b ? -1 : 1\n    })\n\n    let transformedFiles: Map<number, string | Buffer> | undefined\n    if (fileSet.transformedFiles) {\n      transformedFiles = new Map()\n\n      const indexMap = new Map<number, number>()\n      for (const [newIndex, [oldIndex]] of sortedFileEntries.entries()) {\n        indexMap.set(oldIndex, newIndex)\n      }\n\n      for (const [oldIndex, value] of fileSet.transformedFiles) {\n        const newIndex = indexMap.get(oldIndex)\n        if (newIndex === undefined) {\n          throw new Error(`Internal error: ${fileSet.files[oldIndex]} was lost while ordering asar`)\n        }\n        transformedFiles.set(newIndex, value)\n      }\n    }\n\n    return {\n      src: fileSet.src,\n      destination: fileSet.destination,\n      metadata: fileSet.metadata,\n      files: sortedFileEntries.map(([, file]) => file),\n      transformedFiles,\n    }\n  }\n\n  private async checkAgainstRoots(target: string, allowRoots: string[]): Promise<boolean> {\n    const resolved = await resolvePath(target)\n    if (resolved == null || isEmptyOrSpaces(resolved)) {\n      return false\n    }\n\n    for (const root of allowRoots) {\n      if (resolved === root || resolved.startsWith(root + path.sep)) {\n        return true\n      }\n    }\n    return false\n  }\n\n  private async protectSystemAndUnsafePaths(file: string, workspaceRoot: string): Promise<void> {\n    const resolved = await resolvePath(file)\n    const logFields = { source: file, realPath: resolved }\n\n    const workspace = await resolvePath(workspaceRoot)\n\n    // If in workspace, always safe\n    if (workspace && resolved?.startsWith(workspace)) {\n      return\n    }\n\n    // Check allowlist (priority)\n    if (await this.checkAgainstRoots(file, await ALLOWLIST)) {\n      return\n    }\n\n    // Check denylist\n    if (await this.checkAgainstRoots(file, await DENYLIST)) {\n      log.error(logFields, `denied access to system or unsafe path`)\n      throw new Error(`Cannot copy file [${file}] symlinked to file [${resolved}] outside the package to a system or unsafe path`)\n    }\n\n    // Default: outside explicit paths but not explicitly denied\n    log.debug(logFields, `path is outside of explicit safe paths, defaulting to safe`)\n  }\n}\n"]}